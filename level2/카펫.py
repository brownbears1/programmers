"""
카펫의 가로는 세로보다 작을 수 없음
테두리는 무조건 갈색으로 쌓여 있음

가운데 노랑이 값을 약수로 나눔.
다음 나온 약수에 대해 (가로+2, 세로+2)가 되는 케이스를 구한다.
- 갈색은 무조건 노랑이 전체를 감싸는 테두리 역할을 하기 때문에 노랑이 x,y에 +2를 더한 값이 나온다.

노란색 + 갈색의 합을 약수로 나눈 다음, 나온 약수 x,y 대해 2를 빼서 곱한 값이 노란색인지로 진행해도 되지만
약수의 범위가 커지기 때문에 효율성에서 약간 떨어짐

풀이:
1. 가운데 노랑이 값에 대한 약수를 구한다.
- n의 최대 약수가 sqrt(n) 이하이므로 계산한 후, 소숫점이 있을 경우 올림으로 최대 반복 횟수 계산
2. 카펫의 가로는 세로보다 작을 수 없기 때문에 계산한 약수를 뒤집어서 아래 공식에 대입
3. 노랑이를 둘러싼 사각형의 둘레를 구한다.
4. 둘레를 구할 때, 카펫 2개당 길이 1로 계산하므로 둘레를 구한 다음, 각 모서리에 중복된 카펫의 개수인 4를 뺀다.
5. brown 카펫 개수와 5번의 개수가 같다면 반환
"""

import math


def solution(brown, yellow):

    # n의 최대 약수가 sqrt(n) 이하이므로 계산한 후, 소숫점이 있을 경우 올림으로 최대 반복 횟수 계산
    for i in range(1, int(math.sqrt(yellow)) + 1):
        q, r = divmod(yellow, i)
        if not r:
            x, y = (q + 2), (i + 2)

            if brown == (x + y) * 2 - 4:
                return [x, y]


assert solution(10, 2) == [4, 3]
assert solution(8, 1) == [3, 3]
assert solution(24, 24) == [8, 6]
