"""
주어진 수보다 크고 비트 자릿수가 1~2개만 다른 최소값 구하기
수가 짝수일 때, 가장 마지막에 있는 0을 1로 바꿔만 주면 됨
홀수일 경우, 0을 찾아 1로 바꿔주고 그 다음 인덱스의 값을 역전시키면 된다.
즉, 01 -> 10으로

비트 연산자로만 푼 답이 있길래 퍼왔다.
"""


def solution(numbers):
    def rrplace(target, old, new, count):
        return target[::-1].replace(old[::-1], new[::-1], count)[::-1]

    answer = []
    for number in numbers:
        _bin = '0' + format(number, 'b')
        if number % 2:
            result = int(rrplace(_bin, '01', '10', 1), 2)
        else:
            result = number + 1

        answer.append(result)

    return answer


def solution(numbers):
    """
    짝수를 이진수로 나타내면 무조건 끝의 자리는 0으로 끝나게 됩니다. 그러므로 짝수의 경우에는 비트 1~2개 차이가 나면 되니까, 해당 수에 1을 더하기만 하면 됩니다. 홀수의 경우에는 몇가지 수를 대입해서 확인해보시면 알겠지만, 결국에는 오른쪽에서부터 왼쪽으로 연속해서 1이 이어지다가 처음으로 0이 나온 위치를 파악하여, 해당 위치의 두칸 뒤의 자리까지 1로 채운 수 + 1만큼 더하면 됩니다. 예를 들어, 1001111이면, 1010111이 답이 되는데요.
    어차피 여기서 원래의 값에 (원래의 값 + 1)을 XOR 연산을 하면, 최초로 0이 나온 자리까지 1이 연속으로 된 숫자만 나오게 됩니다(그 이상은 무조건 같은 수니까 다 씹히고, 이하의 수는 1이 한 번만 등장하니까 1이 되어서).
    그런데 짝수는 무조건 오른쪽에서 첫번째 자리에서 처음으로 0이 나오니까 (val ^ (val + 1)) >> 2 값은 무조건 0으로 됩니다. 그러면 나머지 val + 1만 남게되어, 결국 제가 처음에 말한대로 짝수의 경우는 무조건 해당 수에 1을 더하기만 하는 규칙대로 나오게 됩니다.
    홀수의 경우는 원래의 값에서 + 1 한 숫자인 val + 1에, 처음으로 0이 나온 위치-2 한만큼까지 1이 연속된 수를 더하기만 하면 되는데요. 아까의 예시로 보았을 때 1001111과 1010111을 XOR 연산을 하면 11111이 나오는데 >> 2를 하면 111이 됩니다(0이 오른쪽에서 5번째에 등장하는데, 2를 빼니까 3번째까지 1이 연속된 숫자인 111이 나오는 것). 방금 더한 과정을 식으로 나타내면 (val ^ (val + 1)) >> 2이 되는 것입니다.
    """
    answer = []
    for val in numbers:
        answer.append(((val ^ (val+1)) >> 2) +val +1)

    return answer


assert solution([2,7]) == [3,11]
assert solution([1001,337,0,1,333,673,343,221,898,997,121,1015,665,779,891,421,222,256,512,128,100]) == [1002, 338, 1, 2, 334, 674, 347, 222, 899, 998, 122, 1019, 666, 781, 893, 422, 223, 257, 513, 129, 101]
